#!/usr/bin/env node

/* eslint quotes: "off" */

'use strict';

const bio = require('bufio');
const fs = require('bfile');
const Path = require('path');
const BLAKE2b = require('bcrypto/lib/blake2b');
const hash256 = require('bcrypto/lib/hash256');
const merkle = require('bcrypto/lib/mrkl');
const consensus = require('../lib/protocol/consensus');
const Network = require('../lib/protocol/network');
const Address = require('../lib/primitives/address');
const AirdropProof = require('../lib/primitives/airdropproof');
const Block = require('../lib/primitives/block');
const TX = require('../lib/primitives/tx');
const Witness = require('../lib/script/witness');
const util = require('../lib/utils/util');
const reserved = require('../lib/covenants/reserved');
const pkg = require('../package.json');
const {AIRDROP_ROOT, FAUCET_ROOT} = AirdropProof;
const NAME_ROOT = merkle.createRoot(BLAKE2b, [...reserved.keys()]);

const networks = {
  main: Network.get('main'),
  testnet: Network.get('testnet'),
  regtest: Network.get('regtest'),
  simnet: Network.get('simnet')
};

function readHeader(str) {
  if (str.length !== 160)
    throw new Error('Invalid hex string.');

  const data = Buffer.from(str, 'hex');

  if (data.length !== 80)
    throw new Error('Invalid header length.');

  const br = bio.read(data);

  return {
    hash: hash256.digest(data),
    version: br.readU32(),
    prevBlock: br.readHash(),
    merkleRoot: br.readHash(),
    time: br.readU32(),
    bits: br.readU32(),
    nonce: br.readU32()
  };
}

function createGenesis(options) {
  const genesis = Address.fromHash(consensus.GENESIS_KEY, 0);
  const nonce = options.nonce >>> 0;

  let flags = options.flags;

  if (!flags)
    flags = consensus.ZERO_HASH;

  const tx = new TX({
    version: 0,
    inputs: [{
      prevout: {
        hash: consensus.ZERO_HASH,
        index: 0xffffffff
      },
      witness: new Witness([flags, NAME_ROOT, AIRDROP_ROOT, FAUCET_ROOT]),
      sequence: 0xffffffff
    }],
    outputs: [
      {
        value: consensus.GENESIS_REWARD,
        address: genesis
      }
    ],
    locktime: 0
  });

  tx.refresh();

  const block = new Block({
    version: 0,
    prevBlock: consensus.ZERO_HASH,
    merkleRoot: consensus.ZERO_HASH,
    witnessRoot: consensus.ZERO_HASH,
    treeRoot: consensus.ZERO_HASH,
    reservedRoot: consensus.ZERO_HASH,
    time: options.time,
    bits: options.bits,
    nonce: nonce,
    extraNonce: Buffer.alloc(consensus.NONCE_SIZE, 0x00),
    mask: consensus.ZERO_HASH
  });

  block.txs.push(tx);

  block.merkleRoot = block.createMerkleRoot();
  block.witnessRoot = block.createWitnessRoot();

  return block;
}

function formatJS(name, block) {
  let out = '';

  out += `genesis.${name} = {\n`;
  out += `  version: ${block.version},\n`;
  out += `  hash: Buffer.from(\n`;
  out += `    '${block.hash().toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  prevBlock: Buffer.from(\n`;
  out += `    '${block.prevBlock.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  merkleRoot: Buffer.from(\n`;
  out += `    '${block.merkleRoot.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  witnessRoot: Buffer.from(\n`;
  out += `    '${block.witnessRoot.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  treeRoot: Buffer.from(\n`;
  out += `    '${block.treeRoot.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  reservedRoot: Buffer.from(\n`;
  out += `    '${block.reservedRoot.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  time: ${block.time},\n`;
  out += `  bits: 0x${util.hex32(block.bits)},\n`;
  out += `  nonce: 0x${util.hex32(block.nonce)},\n`;
  out += `  extraNonce: Buffer.from(\n`;
  out += `    '${block.extraNonce.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  mask: Buffer.from(\n`;
  out += `    '${block.mask.toString('hex')}',\n`;
  out += `    'hex'),\n`;
  out += `  height: 0,\n`;
  out += `  magic: ${block.hash().readUInt32BE(0)}\n`;
  out += `};`;

  return out;
}

function formatC(name, block) {
  const hdr = block.toHead().toString('hex');
  const upper = name.toUpperCase();
  const chunks = [`static const uint8_t HSK_GENESIS_${upper}[] = ""`];

  for (let i = 0; i < hdr.length; i += 26)
    chunks.push(`  "${hdr.slice(i, i + 26)}"`);

  const hex = chunks.join('\n');
  const data = hex.replace(/([a-f0-9]{2})/g, '\\x$1');

  return `${data};`;
}

function writeJS(blocks) {
  const code = [
    '// Autogenerated, do not edit.',
    '',
    `'use strict';`,
    '',
    `const data = require('./genesis-data.json');`,
    'const genesis = exports;',
    ''
  ];

  for (const name of Object.keys(blocks)) {
    const upper = name[0].toUpperCase() + name.substring(1);
    const block = blocks[name];
    code.push('/*');
    code.push(` * ${upper}`);
    code.push(' */');
    code.push('');
    code.push(formatJS(name, block));
    code.push('');
    code.push(`genesis.${name}Data = Buffer.from(data.${name}, 'base64');`);
    code.push('');
  }

  const file = Path.resolve(__dirname, '..', 'lib', 'protocol', 'genesis.js');

  fs.writeFileSync(file, code.join('\n'));
}

function writeJSON(blocks) {
  const json = JSON.stringify({
    main: blocks.main.encode().toString('base64'),
    testnet: blocks.testnet.encode().toString('base64'),
    regtest: blocks.regtest.encode().toString('base64'),
    simnet: blocks.simnet.encode().toString('base64')
  }, null, 2);

  const file = Path.resolve(__dirname, '..', 'lib',
                            'protocol', 'genesis-data.json');

  fs.writeFileSync(file, json + '\n');
}

function writeC(blocks) {
  const code = [
    '#ifndef _HSK_GENESIS_H',
    '#define _HSK_GENESIS_H',
    '',
    '/* Autogenerated, do not edit. */',
    ''
  ];

  for (const name of Object.keys(blocks)) {
    const upper = name[0].toUpperCase() + name.substring(1);
    const block = blocks[name];
    code.push('/*');
    code.push(` * ${upper}`);
    code.push(' */');
    code.push('');
    code.push(formatC(name, block));
    code.push('');
  }

  code.push('#endif');
  code.push('');

  const file = Path.resolve(__dirname, '..', 'etc', 'genesis.h');

  fs.writeFileSync(file, code.join('\n'));
}

function generate(str) {
  let time = Math.floor(Date.now() / 1000);
  let flags = null;

  if (str != null) {
    const hdr = readHeader(str);

    time = hdr.time;
    flags = hdr.hash;
  }

  return {
    main: createGenesis({
      bits: networks.main.pow.bits,
      time,
      flags
    }),
    testnet: createGenesis({
      bits: networks.testnet.pow.bits,
      time: time + 1,
      flags
    }),
    regtest: createGenesis({
      bits: networks.regtest.pow.bits,
      time: time + 2,
      flags
    }),
    simnet: createGenesis({
      bits: networks.simnet.pow.bits,
      time: time + 3,
      flags
    })
  };
}

const USAGE = `hsd-genesis

Usage:

  $ hsd-genesis [string]

Where [string] is the Bitcoin block header at height
615817 serialized as a hexadecimal string.

This script will create the Handshake genesis block
using Bitcoin block 615817 as a commitment and inject
it into the codebase.

Please be sure the block header you pass is height
615817. Any other block will result in you forking
off to your own network!

At Bitcoin height 615823, block 615817 is considered
"final", meaning no deep reorgs after this should
affect the Handshake genesis block. If there is a
reorganization on Bitcoin sooner than this, you will
need to regenerate the genesis block by running this
script again with the *new* block 615817 header.

It is not recommended to run this script before height
615823 is reached on Bitcoin.`;

function main(argv) {
  let str = argv[2];

  if (argv[2] === '--force') {
    str = null;
  } else {
    if (pkg.version !== '2.0.0') {
      console.error('Not enabled yet.');
      return 1;
    }

    if (argv.length !== 3 || argv[2].length !== 160) {
      console.error(USAGE);
      return 1;
    }
  }

  const blocks = generate(str);

  writeJS(blocks);
  writeJSON(blocks);
  writeC(blocks);

  return 0;
}

process.exit(main(process.argv.slice()));
