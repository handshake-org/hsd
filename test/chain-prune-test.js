/* eslint-env mocha */
/* eslint prefer-arrow-callback: "off" */

'use strict';

const assert = require('bsert');
const Network = require('../lib/protocol/network');
const WorkerPool = require('../lib/workers/workerpool');
const Miner = require('../lib/mining/miner');
const Chain = require('../lib/blockchain/chain');

const network = Network.get('regtest');

describe('Chain Prune', function() {
  describe('Prune options', function() {
    const chainOptions = {
      memory: true,
      network
    };

    it('should not allow retroactive prune', async () => {
      const chain = new Chain(chainOptions);

      await chain.open();
      await chain.close();

      // Retroactively enable prune.
      await assert.rejects(async () => {
        chain.options.prune = true;
        await chain.open();
      }, {
        message: 'Cannot retroactively prune.'
      });
      await chain.close();
    });

    it('should not allow retroactive unprune', async () => {
      const chain = new Chain({
        ...chainOptions,
        prune: true
      });

      await chain.open();
      await chain.close();

      await assert.rejects(async () => {
        chain.options.prune = false;
        await chain.open();
      }, {
        message: 'Cannot retroactively unprune.'
      });
      await chain.close();
    });

    it('should force retroactive prune', async () => {
      const chain = new Chain({
        ...chainOptions
      });

      await chain.open();
      await chain.close();

      let pruned = false;
      await assert.doesNotReject(async () => {
        chain.options.forceFlags = true;
        chain.options.prune = true;

        chain.db.prune = () => {
          pruned = true;
        };

        await chain.open();
      });

      await chain.close();
      assert.strictEqual(pruned, true, 'should call prune.');
    });
  });

  describe('Prune', function() {
    const PRUNE_AFTER_HEIGHT = network.block.pruneAfterHeight;
    const KEEP_BLOCKS = network.block.keepBlocks;

    const workers = new WorkerPool({
      enabled: true,
      size: 2
    });

    const chainoptions = {
      memory: true,
      network,
      workers
    };

    let chain, miner, cpu;

    beforeEach(async () => {
      await workers.open();

      network.block.pruneAfterHeight = 10;
      network.block.keepBlocks = 10;

      chain = new Chain(chainoptions);
      miner = new Miner({ chain });
      cpu = miner.cpu;

      await miner.open();
    });

    afterEach(async () => {
      network.block.pruneAfterHeight = PRUNE_AFTER_HEIGHT;
      network.block.keepBlocks = KEEP_BLOCKS;

      if (chain.opened)
        await chain.close();

      await miner.close();
      await workers.open();
    });

    it('should prune blocks', async () => {
      chain.options.prune = true;

      await chain.open();

      const hashes = [];

      // 10 behined height check + 10 pruned + 10 keep blocks
      for (let i = 0; i < 30; i++) {
        const block = await cpu.mineBlock();
        hashes.push(block.hash());
        assert(block);
        assert(await chain.add(block));
      }

      // behined height check
      for (let i = 0; i < 10; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert(block, 'could not get block before height check.');
      }

      // pruned blocks - nulls
      for (let i = 10; i < 20; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert.strictEqual(block, null, `block ${i} was not pruned.`);
      }

      // keep blocks
      for (let i = 20; i < 30; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert(block, `block ${i} was pruned.`);
      }
    });

    it('should retroactively prune', async () => {
      await chain.open();

      const hashes = [];

      for (let i = 0; i < 30; i++) {
        const block = await cpu.mineBlock();
        hashes.push(block.hash());
        assert(block);
        assert(await chain.add(block));
      }

      // make sure all blocks are there
      for (let i = 0; i < 30; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert(block);
      }

      await chain.close();

      chain.options.forceFlags = true;
      chain.options.prune = true;

      // this should call prune on open.
      await chain.open();

      // after prune we should end up with same state as above.
      // behined height check
      for (let i = 0; i < 10; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert(block, 'could not get block before height check.');
      }

      // pruned blocks - nulls
      for (let i = 10; i < 20; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert.strictEqual(block, null, `block ${i} was not pruned.`);
      }

      // keep blocks
      for (let i = 20; i < 30; i++) {
        const block = await chain.getBlock(hashes[i]);
        assert(block, `block ${i} was pruned.`);
      }
    });
  });
});
